
-- Pass position of the array to ACUMULA --

mov r0, #100		; memory pointer of array						<- 
push r0				; enqueue										<-

---

Function ACUMULA (receives by parameter pointer to array)

---

pop r0				; dequeue - recieve the start position of array <-
mov addr0, r0		; saves RAM[0] the start index of array			<-

mov r0, #0															<-
mov addr1, r0		; saves RAM[1] the c variable currently 0		<-
mov r1, #100		; local variable i (inverse order)				<- 


FOR_LOOP:

djnz r1, LOOP_INSIDE ; break condition of for						<-
EPILOGUE:			
sjmp $				; here we must consult RAM[1]					<-


LOOP_INSIDE:
mov r2, addr0		; r2 is used as base, to add with the index		<-
add r2, r1			; base + i										<-
mov r3, @r2			; r3 contains array[i]							<-

push r3																<-
pop r2				; r2 is just to make the compare				<-

sub r2, r1															<-
jnz r2, IF_INSIDE	; array[i] - i != 0								<-
sjmp FOR_LOOP														<-

IF_INSIDE:
mov r0, addr1		; r0 contains now the current c					<-
push r0				; enqueue - c									<-
push r3				; enqueue - array[i]							<-
lcall SOMA			; enqueue - pc									<-
mov addr1, r0		; (c = SOMA(array[i], c))						<-		
sjmp FOR_LOOP														<-


---

Function SOMA (receives by parameters array[i] and c)

---

SOMA:
pop r2				; dequeue - pc (we need this to get the parameters) <-
pop r3				; dequeue - array[i]								<-
pop r0				; dequeue - c										<-

add r0, r3			; SUM is made here and is restored on r0!			<-

push r2				; enqueue - pc (restore program counter)			<-
ret					; dequeue - pc										<-





